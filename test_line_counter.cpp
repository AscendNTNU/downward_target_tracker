#define CONVERT_MJPG   1
#define USBCAM_DEBUG
#define DEVICE_NAME    "/dev/video0"
#define CAMERA_WIDTH   800
#define CAMERA_HEIGHT  600
#define CAMERA_BUFFERS 3
#include "src/asc_usbcam.h"
#include <stdint.h>
#include <signal.h>
#include <time.h>
#include <pthread.h>
#include <assert.h>

uint64_t getnsec()
{
    struct timespec ts = {};
    clock_gettime(CLOCK_REALTIME, &ts);
    uint64_t result = ((uint64_t)ts.tv_sec)*1000000000 +
                      ((uint64_t)ts.tv_nsec);
    return result;
}

void ctrlc(int)
{
    exit(0);
}

volatile bool line_counter_jpg_available = false;
volatile bool line_counter_using_jpg = false;
volatile unsigned int line_counter_jpg_size;
static unsigned char line_counter_jpg_data[CAMERA_WIDTH*CAMERA_HEIGHT*3];

void *main_line_counter(void *)
{
    printf("line counter!\n");
    for (int frame = 0;; frame++)
    {
        while (!line_counter_jpg_available)
        {
        }

        line_counter_jpg_available = false;
        line_counter_using_jpg = true;

        float dt_fwrite = 0.0f;
        {
            uint64_t t1 = getnsec();
            FILE *f = fopen("test.jpg", "w+");
            assert(f);
            fwrite(line_counter_jpg_data, line_counter_jpg_size, 1, f);
            fclose(f);
            uint64_t t2 = getnsec();
            dt_fwrite = (t2-t1)/1e9;
        }

        usleep(50*1000);

        printf("%d. %.2f ms\n", frame, 1000.0f*dt_fwrite);

        line_counter_using_jpg = false;
    }
}

unsigned int mjpg_to_jpg(unsigned char *mjpg, unsigned int mjpg_size, unsigned char *jpg)
{
    static unsigned char huffman[] =
    {
        // JPEG magic
        // 0xff, 0xd8,

        // Text comment
        // 0xff, 0xfe, 0x00, 0x10 0x4c, 0x61 0x76, 0x63 0x35, 0x36 0x2e, 0x36 0x30, 0x2e 0x31, 0x30 0x30, 0x00,

        // Huffman table
        0xff, 0xc4, 0x01, 0xa2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x10, 0x00,
        0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 0x01,
        0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22,
        0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24,
        0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29,
        0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
        0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
        0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
        0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
        0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6,
        0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3,
        0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
        0xfa, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01,
        0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07,
        0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33,
        0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19,
        0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46,
        0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85,
        0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3,
        0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
        0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,
        0xf7, 0xf8, 0xf9, 0xfa
    };

    unsigned int jpg_size = mjpg_size+sizeof(huffman);
    if (!jpg)
        return jpg_size;

    // search for Start of Frame (SOF0) marker
    unsigned int i = 0;
    while ((i+1) < mjpg_size && !(mjpg[i] == 0xff && mjpg[i+1] == 0xc0))
        i++;

    // and squeeze huffman table inbetween
    memcpy(jpg,                   mjpg,    i);
    memcpy(jpg+i,                 huffman, sizeof(huffman));
    memcpy(jpg+i+sizeof(huffman), mjpg+i,  mjpg_size-i);
    return jpg_size;
}

void usbcam_lock_mjpg(unsigned char **jpg_data, unsigned int *jpg_size, timeval *timestamp)
{
    unsigned char *mjpg_data = 0;
    unsigned int mjpg_size = 0;
    usbcam_lock(&mjpg_data, &mjpg_size, timestamp);

    static unsigned char static_jpg_data[CAMERA_WIDTH*CAMERA_HEIGHT*3];
    *jpg_size = mjpg_to_jpg(mjpg_data, mjpg_size, static_jpg_data);
    *jpg_data = static_jpg_data;
}

int main(int, char **)
{
    {
        pthread_t t;
        pthread_create(&t, NULL, main_line_counter, NULL);
    }

    signal(SIGINT, ctrlc);

    {
        usbcam_opt_t opt = {0};
        opt.device_name = DEVICE_NAME;
        opt.pixel_format = V4L2_PIX_FMT_MJPEG;
        opt.width = CAMERA_WIDTH;
        opt.height = CAMERA_HEIGHT;
        opt.buffers = CAMERA_BUFFERS;
        usbcam_init(opt);
    }

    for (int frame = 0;; frame++)
    {
        // RECEIVE LATEST IMAGE
        unsigned char *jpg_data = 0;
        unsigned int jpg_size = 0;
        timeval timestamp = {0};
        #if CONVERT_MJPG==1
        usbcam_lock_mjpg(&jpg_data, &jpg_size, &timestamp);
        #else
        usbcam_lock(&jpg_data, &jpg_size, &timestamp);
        #endif

        float dt_memcpy = 0.0f;
        if (!line_counter_using_jpg)
        {
            uint64_t t1 = getnsec();
            memcpy(line_counter_jpg_data, jpg_data, jpg_size);
            line_counter_jpg_size = jpg_size;
            line_counter_jpg_available = true;
            uint64_t t2 = getnsec();
            dt_memcpy = (t2-t1)/1e9;
        }

        // MEASURE TIME BETWEEN WHEN IMAGES WERE TAKEN
        float dt_frame = 0.0f;
        {
            uint64_t sec = (uint64_t)timestamp.tv_sec;
            uint64_t usec = (uint64_t)timestamp.tv_usec;
            uint64_t t = sec*1000*1000 + usec;
            static uint64_t last_t = t;
            dt_frame = (t-last_t)/1e6;
            last_t = t;
            // printf("%d. %.2f ms\t %.2f ms\n", frame, 1000.0f*dt_frame, 1000.0f*dt_memcpy);
        }

        usbcam_unlock();
    }

    return 0;
}
